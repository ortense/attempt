![Attempt banner - the attempt mascot generated by dall-e 2](https://raw.githubusercontent.com/ortense/attempt/main/media/mascot.png)

# @ortense/attempt
![npm](https://img.shields.io/npm/v/@ortense/attempt)
[![Coverage Status](https://coveralls.io/repos/github/ortense/attempt/badge.svg)](https://coveralls.io/github/ortense/attempt)
![Made with Love](https://img.shields.io/badge/Made%20with-%E2%9D%A4-red)


A minimalist TypeScript library for safe error handling using the Result Type pattern.

[ðŸ‡§ðŸ‡· VersÃ£o em PortuguÃªs](README.pt-br.md)

## Installation

```bash
npm install @ortense/attempt  # npm
yarn add  @ortense/attempt    # yarn
pnpm add @ortense/attempt     # pnpm
bun add @ortense/attempt      # bun
```

## Why use it?

- ðŸŽ¯ **Type-safe**: Error handling with type safety
- ðŸŽ¨ **Elegant**: Simple and expressive API
- ðŸ”’ **Safe**: No uncaught exceptions
- ðŸª¶ **Light**: Zero dependencies
- ðŸ“¦ **Small**: Minimal bundle size
- ðŸ’ª **Robust**: 100% tested

## Basic Usage

```typescript
import { attempt, attemptAsync } from '@ortense/attempt'

// Synchronous code
const result = attempt(() => {
  const number = parseInt("123")
  if (isNaN(number)) throw new Error("Invalid number")
  return number
})

if (result.success) {
  console.log(result.value) // 123
} else {
  console.error(result.error) // Error
}

// Asynchronous code
const result = await attemptAsync(
  fetch("https://api.example.com/data")
    .then(response => response.json())
);

if (result.success) {
  console.log(result.value) // API data
} else {
  console.error(result.error.message) // "API failure"
}
```

## API

### Types

```typescript
type Success<T> = {
  success: true
  value: T
}

type Failure<E extends Error> = {
  success: false
  error: E
}

type Result<T, E extends Error> = Success<T> | Failure<E>

type Match<T, E extends Error> = {
  success: (value: T) => void;
  failure: (error: E) => void;
}
```

### Functions

#### `success<T>(value: T): Success<T>`
Creates a success result containing a value.

```typescript
const result = success(42)
// { success: true, value: 42 }
```

#### `match<T, E extends Error>(result: Result<T, E>, match: Match<T, E>): void`
Executes different callbacks based on the result state.

```typescript
match(result, {
  success: (value) => console.log("Success:", value),
  failure: (error) => console.error("Failure:", error),
})
```

#### `failure<E extends Error>(error: unknown): Failure<E>`
Creates a failure result containing an error.

```typescript
const result = failure(new Error("Something went wrong"))
// { success: false, error: Error("Something went wrong") }

// Strings are converted to Error
const result = failure("Something went wrong")
// { success: false, error: Error("Something went wrong") }
```

#### `attempt<T, E extends Error>(fn: () => T): Result<T, E>`
Executes a function and captures any thrown error.

```typescript
const result = attempt(() => {
  if (Math.random() > 0.5) throw new Error("Bad luck!")
  return "Lucky!"
})

if (result.success) {
  console.log(result.value) // "Lucky!"
} else {
  console.error(result.error) // Error("Bad luck!")
}
```

#### `attemptAsync<T, E extends Error>(Promise<T>): Promise<Result<T, E>>`
Resolves a promise and captures any thrown error.

```typescript
const result = await attemptAsync(
  fetch("https://api.example.com/data")
    .then(response.json())
)

if (result.success) {
  console.log(result.value) // API data
} else {
  console.error(result.error) // "API failure"
}
```

## Advanced Examples

### Custom Errors

```typescript
class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number
  ) {
    super(message)
    this.name = "ApiError"
  }
}

const result = attempt(() => {
  throw new ApiError("Unauthorized", 401)
})

if (!result.success) {
  console.log(result.error.statusCode) // 401
}
```

### Type Narrowing

```typescript
function processResult(result: Result<number, Error>) {
  if (result.success) {
    // TypeScript knows result.value is number
    return result.value * 2
  } else {
    // TypeScript knows result.error is Error
    return result.error.message
  }
}
```

### Operation Composition

```typescript
const getUser = async (id: string) => {
  const result = await attemptAsync(
    fetch(`/api/users/${id}`)
      .then(response => {
        if (!response.ok) throw new Error("User not found")
        return response
      })
      .then(response => response.json())
  )

  if (!result.success) {
    return result // early return with error
  }

  // Process only on success
  return attempt(() => {
    const user = result.value
    if (!user.active) throw new Error("Inactive user")
    return user
  })
}
```

## License

MIT Â© [Marcus Ortense](https://github.com/ortense)